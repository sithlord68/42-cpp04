# **************************************************************************** #
#                                                                              #
#                                                         :::      ::::::::    #
#    Makefile                                           :+:      :+:    :+:    #
#                                                     +:+ +:+         +:+      #
#    By: pjolidon <pjolidon@student.42.fr>          +#+  +:+       +#+         #
#                                                 +#+#+#+#+#+   +#+            #
#    Created: 2025/08/15 19:34:50 by yoda              #+#    #+#              #
#    Updated: 2025/09/21 21:41:59 by pjolidon         ###   ########.fr        #
#                                                                              #
# **************************************************************************** #

NAME		=	je_ne_veux_pas_bruler_le_monde

SRC			=	main.cpp \
				Animal.cpp \
				Dog.cpp \
				Cat.cpp \
				Unicorn.cpp \
				Brain.cpp

SRCDIR		=	./
OBJDIR		=	./
BIN			=	${NAME}
CC			=	c++
FLAGS		=	-Wall -Wextra -Werror -std=c++98 -Wshadow
TFLAGS		=	${FLAGS} -g3

# Add folder to files and objects
SRCS		:=	${addprefix ${SRCDIR}, ${SRC}}
OBJS		:=	${addprefix ${OBJDIR}, ${SRC:.c=.o}}

all:	${NAME}

%.o : %.c
	$(CC) $(CFLAGS) -c $< -o $@

${NAME}: ${OBJS}
	${CC} ${FLAGS} ${OBJS} -o ${BIN}

test:	fclean
	${CC} ${TFLAGS} ${SRC} -o ${BIN}

clean:
	${RM} ${OBJ}	
	${RM} ask.txt || true

fclean:	clean
	${RM} ${BIN}

re:	fclean all

#########################################################################
# git push
push:		ppush repos

# git push end-of-day
pushend:	ppushend repos

# prepare git for rendering
render:		prender repos

# git push to all repos
repos:
		${eval DATE = `date "+%Y-%m-%d %Hh%Mm%S"`}
		@REMOTES=$$(git remote); \
		for REMOTE in $$REMOTES; do \
			echo "**** PUSH vers $$REMOTE ****"; \
			git push $$REMOTE; \
			echo "###########################"; \
			echo "# PUSHED $$REMOTE"; \
			echo "###########################"; \
		done; \
		echo "######################################################"; \
		echo "# ${DATE} - pushed"; \
		echo "######################################################"; \

# Debug level request if test commpilation
COMMSG		?= ${shell bash -c 'read -p "Message de commit: " commsg; echo $$commsg'}
	
# prepare Git push 
ppush:		fclean
		${eval DATE = `date "+%Y-%m-%d %Hh%Mm%S"`}
		git add -A
		git commit -m "${DATE} ${COMMSG} - make push"

# prepare End of day git push
ppushend:	fclean
		${eval DATE = `date "+%Y-%m-%d %Hh%Mm%S"`}
		git add -A
		git commit -m "${DATE} - make pushend"

# prepare Git push for rendering
prender:	fclean
		${eval DATE = `date "+%Y-%m-%d %Hh%Mm%S"`}
		git add -A
		${IGNORE} ${OBJS} || true
		${IGNORE} ${TSTFIL} || true
		${IGNORE} *pdf || true
		${IGNORE} *txt || true
		${IGNORE} gnl${SVFILE} || true
		${IGNORE} ./vers || true
		${IGNORE} ${SVFILE} || true
		git commit -m "${DATE} - make render"

ask:	fclean
	@cat Makefile > ask.txt
	@cat *hpp >> ask.txt	
	@cat *cpp >> ask.txt	

.PHONY:		all clean fclean re push pushend render repos ppush ppushend prender ask
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   Animal.hpp                                         :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: pjolidon <pjolidon@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/09/15 14:23:13 by pjolidon          #+#    #+#             */
/*   Updated: 2025/09/21 23:09:15 by pjolidon         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#ifndef ANIMAL_HPP
# define ANIMAL_HPP

# include <iostream>
# include <string>
# include <sstream>

# ifndef ANIMDBG
#  define ANIMDBG 1
# endif

// virtual sur destructeur pour eviter fuite memoire en heritage

class Animal
{
	public:

		Animal( void );									// canon constructeur par defaut
		virtual	~Animal( void );						// canon destructeur

		Animal( Animal const & ct );					// canon constructeur par co;pie

		Animal	& 		operator=( Animal const & rhs );		// canon operateur =

		std::string 	getType( void ) const;
		void			setType( std::string type );
		virtual void	makeSound() const;

	protected:

		std::string	_type;

	private:
	
		static void	AnimalDebug( std::string output, int level );

};

std::ostream &	operator<<(std::ostream & ssOutput, Animal const & object );

#endif
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   Brain.hpp                                          :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: pjolidon <pjolidon@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/09/21 18:51:58 by pjolidon          #+#    #+#             */
/*   Updated: 2025/09/21 23:12:01 by pjolidon         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */


#ifndef	BRAIN_HPP
# define BRAIN_HPP

# ifndef BRNDBG
#  define BRNDBG 1
# endif

# include <iostream>
# include <string>
# include <sstream>

class Brain:
{

	public:

		Brain( void );							// canon default constructor
		~Brain( void );							// canon destructor

		Brain( const Brain & ct );				// canon copy constructor
		Brain & operator=( const Brain & ct );	// canon operator =

		std::string	ideas[100];

	private:
		void	brainDebug( std::string str, int level );
};

std::ostream & operator<<(std::ostream & o, const Brain & object );

#endif/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   Cat.hpp                                            :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: pjolidon <pjolidon@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/09/21 14:27:46 by pjolidon          #+#    #+#             */
/*   Updated: 2025/09/21 23:09:19 by pjolidon         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#ifndef	CAT_HPP
# define CAT_HPP

# include "Animal.hpp"
# include "Brain.hpp"
# include <iostream>
# include <string>
# include <sstream>

# ifndef CATDBG
#  define CATDBG 1
# endif

class Cat: virtual public Animal
{
	public:

		Cat( void );							// canon default constructor
		~Cat( void );							// canon destructor

		Cat( const Cat & cat );					// canon constructor by copy
		void		makeSound() const;
		void		setBrain( void );
		void		getBrain( void );
		Cat & 		operator=( const Cat & cat );  // canon = operator	

	private:

		Brain		*_brain;
		static void	CatDebug( std::string output, int level );

};

std::ostream &	operator<<(std::ostream & ssOutput, Cat const & object );

#endif
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   Dog.hpp                                            :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: pjolidon <pjolidon@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/09/21 14:27:46 by pjolidon          #+#    #+#             */
/*   Updated: 2025/09/21 23:09:21 by pjolidon         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#ifndef	DOG_HPP
# define DOG_HPP

# include "Animal.hpp"
# include "Brain.hpp"
# include <iostream>
# include <string>
# include <sstream>

# ifndef DOGDBG
#  define DOGDBG 1
# endif

class Dog: virtual public Animal
{
	public:

		Dog( void );							// canon default constructor
		~Dog( void );							// canon destructor

		Dog( const Dog & dog );					// canon constructor by copy
		void		makeSound( void ) const;
		void		setBrain( void );
		void		getBrain( void );
		Dog & 		operator=( const Dog & dog );  // canon = operator	

	private:

		Brain		*_brain;
		static void	DogDebug( std::string output, int level );

};

std::ostream &	operator<<(std::ostream & ssOutput, Dog const & object );

#endif
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   Unicorn.hpp                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: pjolidon <pjolidon@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/09/21 14:27:46 by pjolidon          #+#    #+#             */
/*   Updated: 2025/09/21 23:09:17 by pjolidon         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#ifndef	UNICORN_HPP
# define UNICORN_HPP

# include "Animal.hpp"
# include "Brain.hpp"
# include <iostream>
# include <string>
# include <sstream>

# ifndef UNICORNDBG
#  define UNICORNDBG 1
# endif

class Unicorn: virtual public Animal
{
	public:

		Unicorn( void );								// canon default constructor
		~Unicorn( void );								// canon destructor

		Unicorn( const Unicorn & Unicorn );				// canon constructor by copy
		void		makeSound( void ) const;
		Unicorn & operator=( const Unicorn & unicorn );  // canon = operator	

	private:

		Brain		*_brain;
		static void	UnicornDebug( std::string output, int level );

};

std::ostream &	operator<<(std::ostream & ssOutput, Unicorn const & object );

#endif
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   Animal.cpp                                         :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: pjolidon <pjolidon@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/09/15 14:24:44 by pjolidon          #+#    #+#             */
/*   Updated: 2025/09/21 18:34:59 by pjolidon         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "Animal.hpp"
#include <iostream>
#include <string>
#include <sstream>

Animal::Animal( void ): _type("Animal")
{
	AnimalDebug( "Animal \"" + this->_type + "\" under construction", 9);
	return ;
}

Animal::~Animal ( void )
{
	AnimalDebug( "Animal \"" + this->_type + "\" is beeing destructed", 9);
	return ;
}

Animal::Animal( Animal const & ct )
{
	this->setType(ct.getType());
	AnimalDebug( "Animal " + ct._type + " has been constructed", 9);
	return ;
}

Animal	& Animal::operator=( Animal const & rhs )
{
	this->_type = rhs._type;
	AnimalDebug( "Animal " + rhs._type + " has been cloned", 9);
	return *this;
}

void	Animal::AnimalDebug( std::string output, int level )
{
	if (!ANIMDBG || level < ANIMDBG)
		return ;
	std::clog << output << std::endl;
}

std::ostream &	operator<<(std::ostream & ssOutput, Animal const & o )
{
	ssOutput << o.getType();
	return ssOutput;
}

void	Animal::setType( std::string type )
{
	this->_type = type;
	return;
}

std::string	Animal::getType( void ) const
{
	return this->_type;
}

void	Animal::makeSound( void ) const
{
	std::cout << "[" << this->getType() << "]" << "animal language speaking" << std::endl;
	return;
}/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   Brain.cpp                                          :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: pjolidon <pjolidon@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/09/21 18:51:00 by pjolidon          #+#    #+#             */
/*   Updated: 2025/09/21 23:11:56 by pjolidon         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "Brain.hpp"

#include <iostream>
#include <string>
#include <sstream>

Brain::Brain( void )
{
	brainDebug("Brain constructor called", 1);
	return;
}

Brain::~Brain( void )
{
	brainDebug("Brain destructor called", 1);
	return;
}

Brain::Brain( const Brain & ct )
{
	brainDebug("Brain by copy constructor called", 1);
	return;
}

Brain & Brain::operator=( const Brain & brain )
{
	if ( this != &brain )
	{
		Brain	newBrain = new Brain ( brain );
		this->_brain = newBrain;
	}
	return *this;
}

void	Brain::brainDebug( std::string str, int level )
{
	if (!BRNDBG || BRNDBG > level)
		return;
	std::clog << str << std::endl;
}

std::ostream & operator<<(std::ostream & o, const Brain & object )
{
	int	i = 0;
	while (i < 100)
	{
		if ( !(object.ideas[i]).empty())
			o << object.ideas[i];
		i++;
	}
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   Cat.cpp                                            :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: pjolidon <pjolidon@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/09/21 14:35:27 by pjolidon          #+#    #+#             */
/*   Updated: 2025/09/21 23:07:12 by pjolidon         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "Cat.hpp"
#include <iostream>
#include <string>
#include <sstream>

Cat::Cat( void ):
	Animal(),
	_brain( new Brain )

{
	this->setType("Cat");
	CatDebug("Cat default constructor called", 1);
	return;
}

Cat::~Cat( void )
{
	delete this->_brain;
	CatDebug("Cat destroyer called", 1);
	return;
}

Cat::Cat( const Cat & cat ): 
	Animal(cat),
	_brain( new Brain ( *cat._brain ) )
{
	this->setType(cat.getType());
	CatDebug("Cat copy constructor called", 1);
	return;
}

Cat	& Cat::operator=( const Cat & cat )
{
	if ( this != &cat )
	{
		Animal::operator=( cat );
		Brain	*newBrain = new Brain ( *cat._brain );
		delete this->_brain;
		this->_brain = newBrain;
	}
	return *this;
}

void	Cat::CatDebug( std::string output, int level )
{
	if (!CATDBG || level < CATDBG)
		return ;
	std::clog << output << std::endl;
}

std::ostream &	operator<<(std::ostream & ssOutput, Cat const & o )
{
	ssOutput << o.getType();
	return ssOutput;
}

void	Cat::makeSound( void ) const
{
	std::cout << "[" << this->getType() << "]" << "MEOWWWW !!!!" << std::endl;
	return;
}/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   Dog.cpp                                            :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: pjolidon <pjolidon@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/09/21 14:35:27 by pjolidon          #+#    #+#             */
/*   Updated: 2025/09/21 23:07:34 by pjolidon         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "Dog.hpp"
#include <iostream>
#include <string>
#include <sstream>

Dog::Dog( void ):
	Animal(),
	_brain( new Brain )
{
	this->setType("Dog");
	DogDebug("Cat default constructor called", 1);
	return;
}

Dog::~Dog( void )
{
	delete this->_brain;
	DogDebug("Cat destroyer called", 1);
	return;
}

Dog::Dog( const Dog & dog ):
	Animal(dog),
	_brain(new Brain ( *dog._brain ))
{
	this->setType(dog.getType());
	DogDebug("Dog copy constructor called", 1);
	return;
}

void	Dog::DogDebug( std::string output, int level )
{
	if (!DOGDBG || level < DOGDBG)
		return ;
	std::clog << output << std::endl;
}

Dog	& Dog::operator=( const Dog & dog )
{
	if ( this != &dog )
	{
		Animal::operator=( dog );
		Brain	*newBrain = new Brain ( *dog._brain );
		delete this->_brain;
		this->_brain = newBrain;
	}
	return *this;
}

std::ostream &	operator<<(std::ostream & ssOutput, Dog const & o )
{
	ssOutput << o.getType();
	return ssOutput;
}

void	Dog::makeSound( void ) const
{
	std::cout << "[" << this->getType() << "]" << "WAFF WAFF..." << std::endl;
	return;
}/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   Unicorn.cpp                                        :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: pjolidon <pjolidon@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/09/21 14:35:27 by pjolidon          #+#    #+#             */
/*   Updated: 2025/09/21 23:05:57 by pjolidon         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "Unicorn.hpp"
#include <iostream>
#include <string>
#include <sstream>

Unicorn::Unicorn( void ):
	Animal(),
	_brain( new Brain )
{
	this->setType("Unicorn");
	UnicornDebug("Unicorn default constructor called", 1);
	return;
}

Unicorn::~Unicorn( void )
{
	delete this->_brain;
	UnicornDebug("Unicorn destroyer called", 1);
	return;
}

Unicorn::Unicorn( const Unicorn & unicorn ):
	Animal(unicorn),
	_brain( new Brain ( *unicorn._brain ) )
{
	this->setType(unicorn.getType());
	UnicornDebug("Unicorn copy constructor called", 1);
	return;
}

Unicorn	& Unicorn::operator=( const Unicorn & unicorn )
{
	if ( this != &unicorn )
	{
		Animal::operator=( unicorn );
		Brain	*newBrain = new Brain ( *unicorn._brain );
		delete this->_brain;
		this->_brain = newBrain;
	}
	return *this;
}

void	Unicorn::UnicornDebug( std::string output, int level )
{
	if (!UNICORNDBG || level < UNICORNDBG)
		return ;
	std::clog << output << std::endl;
}

std::ostream &	operator<<(std::ostream & ssOutput, Unicorn const & o )
{
	ssOutput << o.getType();
	return ssOutput;
}

void	Unicorn::makeSound( void ) const
{
	std::cout << "[" << this->getType() << "]" << "HHHHHIIIIIIiiii...." << std::endl;
	return;
}
/* ************************************************************************** */
/*                                                                            */
/*                                                        :::      ::::::::   */
/*   main.cpp                                           :+:      :+:    :+:   */
/*                                                    +:+ +:+         +:+     */
/*   By: pjolidon <pjolidon@student.42.fr>          +#+  +:+       +#+        */
/*                                                +#+#+#+#+#+   +#+           */
/*   Created: 2025/09/15 14:21:39 by pjolidon          #+#    #+#             */
/*   Updated: 2025/09/21 18:54:19 by pjolidon         ###   ########.fr       */
/*                                                                            */
/* ************************************************************************** */

#include "Cat.hpp"
#include "Dog.hpp"
#include "Unicorn.hpp"
#include <iostream>
#include <string>
#include <sstream>

void	myTests( void )
{
	std::cout << "################## my tests ##################" << std::endl;
	Cat		chat;
	Dog		chien;
	Unicorn	licorne;

	chat.makeSound();
	chien.makeSound();
	licorne.makeSound();
	
	Cat		chaton(chat);
	Dog		chiot(chien);
	Unicorn	licorneau(licorne);
}

int	main ( void )
{
	std::cout << "################## STD TESTS #################" << std::endl;
	const Animal* meta = new Animal();
	const Animal* j = new Dog();
	const Animal* i = new Cat();
	std::cout << "TEST CHIEN " << j->getType() << " " << std::endl;
	std::cout << "TEST CHAT " << i->getType() << " " << std::endl;
	std::cout << "TEST CHAT ";
	i->makeSound(); //will output the cat sound!
	std::cout << "TEST CHIEN ";
	j->makeSound();
	std::cout << "TEST ANIMAL ";
	meta->makeSound();
	myTests();
	return 0;
}